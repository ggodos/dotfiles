{
	"CodeForces":{
		"prefix": "cf",
					"body": [
					"#include <bits/stdc++.h>",
					"using namespace std;",
					"",
					"#define nl '\\n'",
					"#define sp << ' ' <<",
					"",
					"using i64 = long long;",
					"using ui64 = unsigned long long;",
					"using ld = long double;",
					"",
					"void solve() {",
					"    $0",
					"}",
					"", "",
					"int main() {",
					"    ios_base::sync_with_stdio(false);",
					"    cin.tie(nullptr);",
					"",
					"    std::ifstream in (\"in.txt\");",
					"    std::streambuf *cinbuf = cin.rdbuf(); // save old buf",
					"    std::cin.rdbuf(in.rdbuf()); // redirect buf",
					"",
					"    std::ofstream out(\"out.txt\");",
					"    std::streambuf *coutbuf = std::cout.rdbuf(); //save old buf",
					"    std::cout.rdbuf(out.rdbuf()); //redirect std::cout to out.txt!",
					"",
					"    int t;",
					"    cin >> t;",
					"    while(t--)",
					"        solve();",
					"",
					"    std::cin.rdbuf(cinbuf);   //reset to standard input again",
					"    std::cout.rdbuf(coutbuf); //reset to standard output again",
					"    return 0;",
					"}"
		],
		"description": "CF Snippet"
	},
	"SegmentedTree": {
		"prefix": "set_tree",
		"body": [
			"vector<int> tree; // Need resize",
			"",
			"void treePrint() {",
			"    for (int i = 1; i < tree.size(); i++) {",
			"        cout << tree[i] << ' ';",
			"    }",
			"    cout << '\\n';",
			"}",
			"",
			"void treeBuild(vector<int> ar, int v, int l, int r) {",
			"    if (l == r)",
			"        tree[v] = ar[l];",
			"    else {",
			"        int m = (l + r) / 2;",
			"        treeBuild(ar, v * 2, l, m);",
			"        treeBuild(ar, v * 2 + 1, m + 1, r);",
			"        tree[v] = tree[v * 2] + tree[v * 2 + 1];",
			"    }",
			"}",
			"",
			"int treeSum(int v, int tl, int tr, int l, int r) {",
			"    if (l > r)",
			"        return 0;",
			"    if (l == tl && r == tr)",
			"        return tree[v];",
			"    else {",
			"        int tm = (tl + tr) / 2;",
			"        return treeSum(v * 2, tl, tm, l, min(tm, r)) +",
			"               treeSum(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);",
			"    }",
			"}",
			"",
			"void treeUpdate(int v, int tl, int tr, int pos, int new_val) {",
			"    if (tl == tr) {",
			"        tree[v] = new_val;",
			"    } else {",
			"        int tm = (tl + tr) / 2;",
			"        if (pos <= tm)",
			"            treeUpdate(v * 2, tl, tm, pos, new_val);",
			"        else",
			"            treeUpdate(v * 2 + 1, tm + 1, tr, pos, new_val);",
			"        tree[v] = tree[v * 2] + tree[v * 2 + 1];",
			"    }",
			"}",
			"$0"
		],
		"description": "Segment tree snippet"
	},
	"FastSegTree": {
		"prefix": "set_tree_fast",
		"body": [
			"void build() {  // build the tree",
			"  for (int i = n - 1; i > 0; --i) t[i] = t[i<<1] + t[i<<1|1];",
			"}",
			"",
			"void modify(int p, int value) {  // set value at position p",
			"  for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = t[p] + t[p^1];",
			"}",
			"",
			"int query(int l, int r) {  // sum on interval [l, r)",
			"  int res = 0;",
			"  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
			"    if (l&1) res += t[l++];",
			"    if (r&1) res += t[--r];",
			"  }",
			"  return res;",
			"}"
		]
	}
}
